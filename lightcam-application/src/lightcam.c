/*------------------------------------------------------------
Light Camera binary for HI3518EV300 50H20L

Main Routine

Contributors:
   Adrien Dirand - initial implementation and documentation.
-------------------------------------------------------------*/

#include <ctype.h>
#include <stdio.h>
#include <unistd.h>
#include <stdint.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <sys/epoll.h>
#include <pthread.h>
#include <poll.h>
#include <time.h>

#include "serial/serial.h"
#include "gpiopmux/gpiopmux.h"
#include "gpiopmux/led.h"

#include "libyaml/yaml.h"

#include "mqtt/MQTTClient.h"

pthread_t gpiothread_id;

/* YAML File structure
mqtt:
	server:<server ip or dns>
	port:<port>
	username:<username>
	password:<password>
	qos:<qos>
	topic:<topic>
serial:
	port:<dev port>
	baudrate:<baudrate>

*/




/*

Configuration:
- Configuration from file or command line
- mqtt configuration : from file
- set gpio direction and value
- set pmux value

Then Start mqtt Client :
- functions
	- low level
		- get/set gpio
		- get/set pmux
		- send byte to serial
	- high level
		- Alarm : gpio alarm to mqtt
		- Led : SetRed, SetGreen
		- Light : Configuration

*/

/**
 * @brief The function will be called whenever a PUBLISH message is received.
 */

char hostname[256];
char mqtt_subscribed_topic[1024];
char mqtt_watchdog_topic[1024];
int watchdog = 0;
int watchdogcnt = 0;
unsigned char buf[100];
unsigned char readbuf[100];

bool gpiodetector = false;
bool detectionstatus = false;

struct struct_detector
{
	bool detectionstatus;
	double maxtempo;
	double begintempo;
};

struct struct_detector strct_detector;

	
struct yaml_mqtt
{
	char* server;
	int port;
	char* username;
	char* password;
	char* topic;
	double detectortempo;
};

struct yaml_serial
{
	char* port;
	int baudrate;
};

/* Our example parser states. */
enum parser_state {
    STATE_NOTSET,
	STATE_START,    /* start state */
    STATE_STREAM,   /* start/end stream */
    STATE_DOCUMENT, /* start/end document */
    STATE_SECTION,  /* top level */
	
	STATE_MQTT,
	STATE_MQTT_KEY,
	STATE_MQTT_SERVER,
	STATE_MQTT_PORT,
	STATE_MQTT_USERNAME,
	STATE_MQTT_PASSWORD,
	STATE_MQTT_TOPIC,
	STATE_MQTT_DETECTORTEMPO,
	
	STATE_SERIAL,
	STATE_SERIAL_KEY,
	STATE_SERIAL_PORT,
	STATE_SERIAL_BAUDRATE,

    STATE_STOP      /* end state */
};

/* Our application parser state data. */
struct yaml_config {
    enum parser_state state;      /* The current parse state */
    struct yaml_mqtt mqtt; /* =
	{
		(char*)"192.168.0.1", 1883, NULL, NULL, (char*)""
	};        /* MQTT data elements. */
    struct yaml_serial serial; /* =
	{
		(char*)"/dev/ttyAMA0", 9600
	};      /* Serial data elements. */
};

struct yaml_config config;

/*
 * Consume yaml events generated by the libyaml parser to
 * import our data into raw c data structures. Error processing
 * is keep to a mimimum since this is just an example.
 */
int consume_event(struct yaml_config *s, yaml_event_t *event)
{

	char *value;
	char *ptr;
	//printf("state=%d event=%d\n", s->state, event->type);
    switch (s->state) {
     case STATE_START: //1
        switch (event->type) {
        case YAML_STREAM_START_EVENT://1
            s->state = STATE_STREAM;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return 0;
        }
        break;

     case STATE_STREAM://2
        switch (event->type) {
        case YAML_DOCUMENT_START_EVENT://3
            s->state = STATE_DOCUMENT;
            break;
        case YAML_STREAM_END_EVENT:
            s->state = STATE_STOP;  /* All done. */
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return 0;
        }
        break;

     case STATE_DOCUMENT://3
        switch (event->type) {
        case YAML_MAPPING_START_EVENT://9
            s->state = STATE_SECTION;
            break;
        case YAML_DOCUMENT_END_EVENT://10
            s->state = STATE_STREAM;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return 0;
        }
        break;

    case STATE_SECTION://4
        switch (event->type) {
        case YAML_SCALAR_EVENT://6
            value = (char *)event->data.scalar.value;
            if (strcmp(value, "mqtt") == 0) {
               s->state = STATE_MQTT;
            } else if (strcmp(value, "serial") == 0) {
               s->state = STATE_SERIAL;
            } else {
               fprintf(stderr, "Unexpected scalar: %s\n", value);
               return 0;
            }
            break;
        case YAML_MAPPING_END_EVENT://10
            s->state = STATE_DOCUMENT;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return 0;
        }
        break;

    case STATE_MQTT://5
        switch (event->type) {
        case YAML_MAPPING_START_EVENT://9
            s->state = STATE_MQTT_KEY;
            break;
        case YAML_MAPPING_END_EVENT://10
            s->state = STATE_SECTION;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return 0;
        }
        break;
	
    case STATE_MQTT_KEY://6
        switch (event->type) {
        case YAML_SCALAR_EVENT://6
            value = (char *)event->data.scalar.value;
            if (strcmp(value, "server") == 0) {
                s->state = STATE_MQTT_SERVER;
            } else if (strcmp(value, "port") == 0) {
                s->state = STATE_MQTT_PORT;
            } else if (strcmp(value, "username") == 0) {
                s->state = STATE_MQTT_USERNAME;
            } else if (strcmp(value, "password") == 0) {
                s->state = STATE_MQTT_PASSWORD;
            } else if (strcmp(value, "topic") == 0) {
                s->state = STATE_MQTT_TOPIC;
            } else if (strcmp(value, "detectortempo") == 0) {
                s->state = STATE_MQTT_DETECTORTEMPO;
            } else {
                fprintf(stderr, "Unexpected key: %s\n", value);
                return 0;
            }
            break;
        case YAML_MAPPING_END_EVENT://10
            s->state = STATE_SECTION;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return 0;
        }
        break;

    case STATE_MQTT_SERVER://7
        switch (event->type) {
        case YAML_SCALAR_EVENT://6
            s->mqtt.server = strdup((char *)event->data.scalar.value);
            s->state = STATE_MQTT_KEY;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return 0;
        }
        break;

    case STATE_MQTT_PORT://8
        switch (event->type) {
        case YAML_SCALAR_EVENT://6
            s->mqtt.port = atoi((char *)event->data.scalar.value);
            s->state = STATE_MQTT_KEY;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return 0;
        }
        break;

    case STATE_MQTT_USERNAME://9
        switch (event->type) {
        case YAML_SCALAR_EVENT://6
            s->mqtt.username = strdup((char *)event->data.scalar.value);
            s->state = STATE_MQTT_KEY;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return 0;
        }
        break;

    case STATE_MQTT_PASSWORD://10
        switch (event->type) {
        case YAML_SCALAR_EVENT://6
            s->mqtt.password = strdup((char *)event->data.scalar.value);
            s->state = STATE_MQTT_KEY;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return 0;
        }
        break;

    case STATE_MQTT_TOPIC://11
        switch (event->type) {
        case YAML_SCALAR_EVENT://6
            s->mqtt.topic = strdup((char *)event->data.scalar.value);
            s->state = STATE_MQTT_KEY;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return 0;
        }
        break;
		
    case STATE_MQTT_DETECTORTEMPO://12
        switch (event->type) {
        case YAML_SCALAR_EVENT://6
            s->mqtt.detectortempo = strtod((char *)event->data.scalar.value, &ptr);
            s->state = STATE_MQTT_KEY;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return 0;
        }
        break;


    case STATE_SERIAL://13
        switch (event->type) {
        case YAML_MAPPING_START_EVENT://9
            s->state = STATE_SERIAL_KEY;
            break;
        case YAML_MAPPING_END_EVENT://10
            s->state = STATE_SECTION;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return 0;
        }
        break;
	
    case STATE_SERIAL_KEY://14
        switch (event->type) {
        case YAML_SCALAR_EVENT://6
            value = (char *)event->data.scalar.value;
            if (strcmp(value, "port") == 0) {
                s->state = STATE_SERIAL_PORT;
            } else if (strcmp(value, "baudrate") == 0) {
                s->state = STATE_SERIAL_BAUDRATE;
            } else {
                fprintf(stderr, "Unexpected key: %s\n", value);
                return 0;
            }
            break;
        case YAML_MAPPING_END_EVENT://10
            s->state = STATE_SECTION;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return 0;
        }
        break;

    case STATE_SERIAL_PORT://15
        switch (event->type) {
        case YAML_SCALAR_EVENT://6
            s->serial.port = strdup((char *)event->data.scalar.value);
            s->state = STATE_SERIAL_KEY;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return 0;
        }
        break;

    case STATE_SERIAL_BAUDRATE://16
        switch (event->type) {
        case YAML_SCALAR_EVENT://6
            s->serial.baudrate = atoi((char *)event->data.scalar.value);
            s->state = STATE_SERIAL_KEY;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return 0;
        }
        break;


    case STATE_STOP://16
        break;
    }
    return 1;
}

volatile int toStop = 0;

void cfinish(int sig)
{
	signal(SIGINT, NULL);
	toStop = 1;
}

void ActiveGPIO(char *strGpio, uint32_t addr, uint32_t value)
{
	
	uint32_t  data = 0;	
	
	printf("Activation GPIO%s (%x -> %x)...", strGpio, value, addr);
	
	pmux_get_cmd(addr, &data);
	
	if(data != value)
	{
		printf("setting value...");
		data = value;
		pmux_set_cmd(addr, &data);
		pmux_get_cmd(addr, &data);
	}
	
	if(data == value)
		printf("done\n");
	else
		printf("error\n");
}

int inithardware()
{
   
	// GPIO Configuration
	
	// Active 	GPIO1_4
	ActiveGPIO("1_4", 0x120c0010, 0x1e02);
	
	// Active 	GPIO1_6
	ActiveGPIO("1_6", 0x120c0018, 0x1d02);
	
	// Active 	GPIO1_7
	ActiveGPIO("1_7", 0x120c001c, 0x1502);
	
	// Active 	GPIO0_3
	ActiveGPIO("0_3", 0x100c000c, 0x1000);

	// Green 1Hz
	setled(LED_GREEN, LED_2HZ);
	
	// alarm gpio
	bool value;	
	value = false;
	printf("alarm gpio configuration...");
	gpio_set_direction("1_5", &value);
	gpio_config_interrupt("1_5");
	printf("done\n");

	// set tty
	printf("Initialize tty...");
	initialize(config.serial.port, config.serial.baudrate, 0);
	printf("done\n");
	
	// send update
	printf("light_update...");
	light_update();
	printf("done\n");
	
}


int GetYamlConfig(char *configfilepath){
	
	int code = 0;
	memset(&config, 0, sizeof(config));
	config.state = STATE_NOTSET;
	config.mqtt.server = "";
	config.mqtt.port = 1883;
	config.mqtt.username = NULL;
	config.mqtt.password = NULL;
	config.mqtt.topic = hostname;
	config.serial.port = "/dev/ttyAMA0";
	config.serial.baudrate = 9600;
	
	printf("Opening YAML config file '%s'\n", configfilepath);

	FILE* configfile;
	char ch;
 
	// Opening file in reading mode
	configfile = fopen(configfilepath, "r");
	
	if(!configfile){
		printf("Cannot open config file '%s'\n", configfile);
		code = EXIT_FAILURE;
	}
	else{


		int status;
		yaml_parser_t parser;


		config.state = STATE_START;
		yaml_parser_initialize(&parser);
		yaml_parser_set_input_file(&parser, configfile);
		do {
			yaml_event_t event;

			status = yaml_parser_parse(&parser, &event);
			if (status == 0) {
				fprintf(stderr, "yaml_parser_parse error\n");
				code = EXIT_FAILURE;
				goto done;
			}
			status = consume_event(&config, &event);
			yaml_event_delete(&event);
			if (status == 0) {
				fprintf(stderr, "consume_event error\n");
				code = EXIT_FAILURE;
				goto done;
			}
		} while (config.state != STATE_STOP);


		code = EXIT_SUCCESS;

	done:
		yaml_parser_delete(&parser);
		fclose(configfile);
		
		
		if(code == EXIT_FAILURE)
		{
			printf("Error during retriving YAML config file\n");
		}
	}

	

	
	printf("============Configuration==============\n");
	printf("config.mqtt.server='%s'\n", config.mqtt.server);
	printf("config.mqtt.port='%d'\n", config.mqtt.port);
	printf("config.mqtt.username='%s'\n", config.mqtt.username);
	printf("config.mqtt.password='%s'\n", config.mqtt.password);
	printf("config.mqtt.topic='%s'\n", config.mqtt.topic);
	printf("config.mqtt.detectortempo='%Le'\n", config.mqtt.detectortempo);
	printf("config.serial.port='%s'\n", config.serial.port);
	printf("config.serial.baudrate='%d'\n", config.serial.baudrate);
	printf("==========fin Configuration============\n");
		
	return code;
}

char *str_replace(char *orig, char *rep, char *with) {
    char *result; // the return string
    char *ins;    // the next insert point
    char *tmp;    // varies
    int len_rep;  // length of rep (the string to remove)
    int len_with; // length of with (the string to replace rep with)
    int len_front; // distance between rep and end of last rep
    int count;    // number of replacements

    // sanity checks and initialization
    if (!orig || !rep)
        return NULL;
    len_rep = strlen(rep);
    if (len_rep == 0)
        return NULL; // empty rep causes infinite loop during count
    if (!with)
        with = "";
    len_with = strlen(with);

    // count the number of replacements needed
    ins = orig;
    for (count = 0; tmp = strstr(ins, rep); ++count) {
        ins = tmp + len_rep;
    }

    tmp = result = malloc(strlen(orig) + (len_with - len_rep) * count + 1);

    if (!result)
        return NULL;

    // first time through the loop, all the variable are set correctly
    // from here on,
    //    tmp points to the end of the result string
    //    ins points to the next occurrence of rep in orig
    //    orig points to the remainder of orig after "end of rep"
    while (count--) {
        ins = strstr(orig, rep);
        len_front = ins - orig;
        tmp = strncpy(tmp, orig, len_front) + len_front;
        tmp = strcpy(tmp, with) + len_with;
        orig += len_front + len_rep; // move to next "end of rep"
    }
    strcpy(tmp, orig);
    return result;
}

void messageArrived(MessageData* md)
{
	MQTTMessage* message = md->message;
	char topic[1024];
	char payload[1024];
	char *cleantopic;
	memset((void*) topic, 0, 1024);
	strncpy(topic, md->topicName->lenstring.data, md->topicName->lenstring.len);
		
	memset((void*) payload, 0, 1024);
	strncpy(payload, (char*)message->payload, (int)message->payloadlen);

	cleantopic = str_replace(topic, config.mqtt.topic, "");

	if(strcmp(cleantopic, "/Watchdog")==0)
	{
		watchdog = (watchdog > 32000 ? 0 : watchdog+1);
		watchdogcnt = -1;
	}
	else
	{
		printf("received: %s=%s\n", cleantopic, payload);
		if(strcmp(cleantopic, "/Set/Update")==0)
		{
			light_update();
		}
		else if(strcmp(cleantopic, "/Set/LightMode")==0)
		{
			if(strcmp(payload, "on")==0)
			{
				light_lightmode(LIGHTMODE_ON);
			}
			else if(strcmp(payload, "detect")==0)
			{
				light_lightmode(LIGHTMODE_DETECT);
			}
			else if(strcmp(payload, "config")==0)
			{
				light_lightmode(LIGHTMODE_CONFIG);
			}
			else
			{
				printf("%s is not a valid payload for LightMode\n", payload);
			}
		}
		else if(strcmp(cleantopic, "/Set/AlarmMode")==0)
		{
			if(strcmp(payload, "on")==0)
			{
				light_alarmmode(ALARMMODE_ON);
			}
			else if(strcmp(payload, "off")==0)
			{
				light_alarmmode(ALARMMODE_OFF);
			}
			else
			{
				printf("%s is not a valid payload for AlarmMode\n", payload);
			}
		}
		else if(strcmp(cleantopic, "/Set/PirSensibility")==0)
		{
			int pirsensibility;
			pirsensibility = atoi(payload);
			if(pirsensibility >= 1 && pirsensibility <= 25)
			{
				light_pirsensibility(pirsensibility);
			}
			else
			{
				printf("%s is not a valid payload for PirSensibility\n", payload);
			}
		}	
		else if(strcmp(cleantopic, "/Set/LuxSensibility")==0)
		{
			int luxsensibility;
			luxsensibility = atoi(payload);
			if(luxsensibility >= 1 && luxsensibility <= 23)
			{
				light_luxsensibility(luxsensibility);
			}
			else
			{
				printf("%s is not a valid payload for LuxSensibility\n", payload);
			}
		}		
		else if(strcmp(cleantopic, "/Set/HighLightLevel")==0)
		{
			int highlightlevel;
			highlightlevel = atoi(payload);
			if(highlightlevel >= 1 && highlightlevel <= 19)
			{
				light_highlightlevel(highlightlevel);
			}
			else
			{
				printf("%s is not a valid payload for HighLightLevel\n", payload);
			}
		}		
		else if(strcmp(cleantopic, "/Set/OnTemporisation")==0)
		{
			if(strcmp(payload, "1")==0)
			{
				light_ontemporisation(ONTEMPORISATION_01MIN);
			}
			else if(strcmp(payload, "3")==0)
			{
				light_ontemporisation(ONTEMPORISATION_03MIN);
			}
			else if(strcmp(payload, "10")==0)
			{
				light_ontemporisation(ONTEMPORISATION_10MIN);
			}
			else if(strcmp(payload, "15")==0)
			{
				light_ontemporisation(ONTEMPORISATION_15MIN);
			}
			else
			{
				printf("%s is not a valid payload for OnTemporisation\n", payload);
			}
		}		
		else if(strcmp(cleantopic, "/Set/LowLightLevel")==0)
		{
			int lowlightlevel;
			lowlightlevel = atoi(payload);
			if(lowlightlevel >= 1 && lowlightlevel <= 12)
			{
				light_lowlightlevel(lowlightlevel);
			}
			else
			{
				printf("%s is not a valid payload for LowLightLevel\n", payload);
			}
		}		
		else if(strcmp(cleantopic, "/Set/LowLightDuration")==0)
		{
			if(strcmp(payload, "-1")==0)
			{
				light_lowlightduration(LOWLIGHTDURATION_ALLNIGHT);
			}
			else if(strcmp(payload, "2")==0)
			{
				light_lowlightduration(LOWLIGHTDURATION_02H);
			}
			else if(strcmp(payload, "4")==0)
			{
				light_lowlightduration(LOWLIGHTDURATION_04H);
			}
			else if(strcmp(payload, "6")==0)
			{
				light_lowlightduration(LOWLIGHTDURATION_06H);
			}
			else if(strcmp(payload, "10")==0)
			{
				light_lowlightduration(LOWLIGHTDURATION_10H);
			}
			else
			{
				printf("%s is not a valid payload for LowLightDuration\n", payload);
			}
		}
		else
		{
			printf("Topic not used '%s'\n", cleantopic);	
		}
	}
	
	free(cleantopic);
	
}


int initmqtt(Network *n, MQTTClient *c, unsigned char *buf, int bufsize, unsigned char *readbuf, int readbufsize)
{
	// Watchdog : 
	//			{basetopic}/Watchdog={0-32000}
	// Up Topic : 
	//			{basetopic}/Get/Detection={0,1}
	// Down Topic :
	//			{basetopic}/Set/Update
	//			{basetopic}/Set/LightMode={on,detect,config}
	//			{basetopic}/Set/AlarmMode={on,off}
	//			{basetopic}/Set/PirSensibility={1-25}
	//			{basetopic}/Set/LuxSensibility={1-23}
	//			{basetopic}/Set/HighLightLevel={1-19}
	//			{basetopic}/Set/OnTemporisation={1,3,10,15}
	//			{basetopic}/Set/LowLightLevel={1-12}
	//			{basetopic}/Set/LowLightDuration={-1,2,4,6,10}

	
	// setting mqtt client
	printf("Setting mqtt client...");
	
	watchdogcnt = 0;
	
	int rc = 0;

	if(c->isconnected)
	{
		MQTTDisconnect(c);
	}

	if (n->my_socket != -1)
	{
		NetworkDisconnect(n);
	}
	printf("\nNetworkInit\n");
	NetworkInit(n);
	printf("NetworkConnect\n");
	if(NetworkConnect(n, config.mqtt.server, config.mqtt.port)==-1)
	{
		printf("Cannot open socket and run NetworkConnect on %s:%d\n", config.mqtt.server, config.mqtt.port);
		return -1;
	}
	else
	{
		printf("MQTTClientInit\n");
		MQTTClientInit(c, n, 1000, buf, bufsize, readbuf, readbufsize);
	 
		MQTTPacket_connectData data = MQTTPacket_connectData_initializer;       
		data.willFlag = 0;
		data.MQTTVersion = 3;
		data.clientID.cstring = hostname;
		data.username.cstring = config.mqtt.username;
		data.password.cstring = config.mqtt.password;

		data.keepAliveInterval = 10;
		data.cleansession = 1;
		printf("Connecting to %s:%d\n", config.mqtt.server, config.mqtt.port);
		
		printf("MQTTConnect\n");
		rc = MQTTConnect(c, &data);
		if(rc)
		{
			printf("Cannot connect to MQTT %s:%d\n", config.mqtt.server, config.mqtt.port);
			NetworkDisconnect(n);
			return -1;
		}
		else
		{

			printf("base topic is %s\n", config.mqtt.topic);
			
			// Set	
			strcpy(mqtt_subscribed_topic, config.mqtt.topic);
			
			strcat(mqtt_subscribed_topic,"/Set/#");
			
			printf("Subscribing to %s\n", mqtt_subscribed_topic);
			rc = MQTTSubscribe(c, mqtt_subscribed_topic, QOS2, messageArrived);
			
			// Watchdog
			strcpy(mqtt_watchdog_topic, config.mqtt.topic);
			
			strcat(mqtt_watchdog_topic,"/Watchdog");
			
			printf("Subscribing to %s\n", mqtt_watchdog_topic);
			rc = MQTTSubscribe(c, mqtt_watchdog_topic, QOS2, messageArrived);
			
			printf("done\n");
			
			return 1;
			
		}
		
		
	
	}

}

int MQTTWatchdog(MQTTClient *c)
{
	int rc = 0;	
		
	MQTTMessage pubmsg;
	
	char watchdogstr[6] = "0";
	
	if(c->isconnected)
	{
	
		//itoa(watchdog,watchdogstr,10);
		sprintf(watchdogstr, "%d", watchdog);

		memset(&pubmsg, '\0', sizeof(pubmsg));
		//pubmsg.payload = (void*)"test";
		pubmsg.payload = (void*)watchdogstr;
		pubmsg.payloadlen = strlen((char*)pubmsg.payload);
		pubmsg.qos = QOS2;
		pubmsg.retained = 0;
		pubmsg.dup = 0;
		
		char topic[1024];
		
		strcpy(topic, config.mqtt.topic);
		
		strcat(topic,"/Watchdog");
		
		rc = MQTTPublish(c, topic, &pubmsg);
	}
	
	if(watchdogcnt<5)
		watchdogcnt++;
	
	
	return watchdogcnt;
}



int MQTTdetector(MQTTClient *c, bool *gpiodetector, struct struct_detector *stct_detector)
{
	int rc;
	char topic[1024];
	MQTTMessage pubmsg;
	
    double time_spent;
    double now;


	if(*gpiodetector)
	{
		// clock seems to be wrong. 1.0 = 71sec
		now = (double)clock() / (double)CLOCKS_PER_SEC * 700.0;
		
		stct_detector->begintempo = now;

		if(!stct_detector->detectionstatus)
		{
			
			stct_detector->detectionstatus = true;
			
				
			if(c->isconnected)
			{
				memset(&pubmsg, '\0', sizeof(pubmsg));
				
				pubmsg.payload = (void*)"1";
				pubmsg.payloadlen = strlen((char*)pubmsg.payload);
				pubmsg.qos = QOS2;
				pubmsg.retained = 0;
				pubmsg.dup = 0;
				
				strcpy(topic, config.mqtt.topic);
				
				strcat(topic,"/Get/Detection");
				
				rc = MQTTPublish(c, topic, &pubmsg);
				printf("Detector ON -> %s=1\n", topic);
			}
			else
				printf("Detector ON\n");
		}
		
		*gpiodetector = false;
	}
	
	
		
	if(!*gpiodetector && stct_detector->detectionstatus)
	{
		// clock seems to be wrong. 1.0 = 71sec
		now = (double)clock() / (double)CLOCKS_PER_SEC * 700.0;
		
		time_spent = now - stct_detector->begintempo;
		
        if (time_spent>=stct_detector->maxtempo)
		{
			stct_detector->detectionstatus = false;

			if(c->isconnected)
			{
				memset(&pubmsg, '\0', sizeof(pubmsg));
				
				pubmsg.payload = (void*)"0";
				pubmsg.payloadlen = strlen((char*)pubmsg.payload);
				pubmsg.qos = QOS2;
				pubmsg.retained = 0;
				pubmsg.dup = 0;
				
				strcpy(topic, config.mqtt.topic);
				
				strcat(topic,"/Get/Detection");
				
				rc = MQTTPublish(c, topic, &pubmsg);
				printf("Detector OFF -> %s=0\n", topic);
			}
			else
				printf("Detector OFF\n");
        }
	}

}

// detection function call as pthread
void *GPIOdetectorCallback(void *args){

	char strvalue[1];
	char strcmpval[1] = "0";  // 0 = detector
	int ret;
	int nn;
	int ep;
	int rc;
	int fd;
	bool *detector = args;
	char topic[1024];

	//struct epoll_event ev, events;
	struct epoll_event ev, events;

	printf("Configuring epoll to gpio13...");

	ep = epoll_create1(0);
	
	fd = open("/sys/class/gpio/gpio13/value", O_RDONLY);
	
	nn = read(fd, strvalue, 1);
	
	ev.events = EPOLLIN | EPOLLET; // EPOLLPRI;
	ev.data.fd = fd;

	ret = epoll_ctl(ep, EPOLL_CTL_ADD, fd, &ev);
	
	lseek(fd, 0, SEEK_SET);
	
	printf("done\n");
	
	while (1)
	{
		ret = epoll_wait(ep, &events, 1, -1);

		if(ret > 0) {
			lseek(fd, 0, SEEK_SET);

			nn = read(fd, strvalue, 1);
			if(strcmp(strvalue, strcmpval)==0)
			{
				*detector = true;
			}
		}
		
	}
	
}



// Main
int main(int argc, char *argv[]) {

	Network n;
	MQTTClient c;


	char *configfilepath;
	int rethostname;
   
    c.isconnected = 0;
	n.my_socket = -1;
	// Get Hostname
    rethostname = gethostname(hostname, sizeof(hostname)); //find the host name
		
	configfilepath = "lightcam.yml";
	
	if(argc == 2)
		configfilepath = argv[1];
	
	printf("LightCam Module to control Light Extension Card, Status Led and configuration\n");
	
	GetYamlConfig(configfilepath);

	inithardware();	
	
	initmqtt(&n, &c, buf, 100, readbuf, 100);

	
	// LED_COLOR { LED_NONE, LED_RED, LED_GREEN };
	// LED_MODE { LED_OFF, LED_ON, LED_02HZ, LED_05HZ, LED_1HZ };


	signal(SIGINT, cfinish);
	signal(SIGTERM, cfinish);

		
	int rc = 0;	
	int cnt = 0;
	

	//*detection(NULL);
	
	toStop = false;
	
	pthread_create(&gpiothread_id, NULL, GPIOdetectorCallback, (void *)&gpiodetector);
	
	printf("Starting main loop...\n");
	
	while (!toStop)
	{
		cnt = MQTTWatchdog(&c);
		if(cnt > 0)
		{
			if(cnt < 5)
				setled(LED_RED, LED_02HZ);
			else
			{
				setled(LED_RED, LED_ON);
				printf("Watchdog timeout, trying to reconnect MQTT...\n");
				sleep(10);
				initmqtt(&n, &c, buf, 100, readbuf, 100);
			}
		}
		else
		{
			MQTTYield(&c, 1000);
			setled(LED_GREEN, LED_ON);
			

			strct_detector.maxtempo = config.mqtt.detectortempo;
			MQTTdetector(&c, &gpiodetector, &strct_detector);
			
		}

	}
	
	
	// stop thread if exists
	if(gpiothread_id)
	{
		pthread_cancel(gpiothread_id);
		
		gpiothread_id = NULL;
	}
	
	printf("Stopping\n");

	MQTTDisconnect(&c);
	NetworkDisconnect(&n);
		
	printf("Closing...");
	
		
	
	setled(LED_NONE, LED_OFF);
	
	printf("done\n");

}
